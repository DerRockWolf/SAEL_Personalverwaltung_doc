{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Projekt \u00dcbersicht \u00b6 Auf dieser Seite befinden sich die Dokumentationen f\u00fcr unser SAEL Projekt: Personalverwaltung . Inhaltsverzeichnis: \u00dcbersicht C# Dokumentation SQL Dokumentation Source Code \u00b6 Der Source Code kann entweder direkt auf GitHub gelesen werden, oder lokal, nachdem der Source Code heruntergeladen wurde: Der Source Code kann entweder mit git clone https://github.com/DerRockWolf/SAEL_Project_Personalverwaltung.git geklont werden oder \u00fcber die Option Download ZIP ( Direct Download ) als ZIP Archiv heruntergeladen werden. Build \u00b6 Da wir in unserem Projekt einen Teil des System.Data.SQLite NuGet-Paket verwenden muss dies zuerst geladen werden: Dies geschied automatisch beim ersten Build . Es ist aber auch m\u00f6glich das Paket zuvor wiederherzustellen: Rechtsklick auf die Projektmappe (Solution) im Projektmappen-Explorer Linksklick auf NuGet-Pakete wiederherstellen Danach kann der Source Code gelesen werden und die gelben Warndreiecke vor den Verweisen im Projektmappen-Explorer verschwinden. WICHTIG Da Visual Studio (MSBuild.exe) die ben\u00f6tigten sqlite.interop.dll Dateien beim 1. Build nicht automatisch in den Build Pfad kopiert muss wie folgt vorgegangen werden: Projektmappe bereinigen: Erstellen > Projektmappe bereinigen Projektmappe erstellen: Erstellen > Projektmappe erstellen Features \u00b6 Datenspeicherung in SQLite Datenbank Erstellen neuer Datenbank-Dateien \u00d6ffnen von bestehenden Datenbank-Dateien \u00dcberpr\u00fcfung des Datenbank Schemas Ver\u00e4nderung der Daten Erstellung neuer Eintr\u00e4ge Bearbeitung von bestehenden Eintr\u00e4gen L\u00f6schen von bestehenden Eintr\u00e4gen Verhalten Pflichfelder (gekennzeichnet mit * ) [Vorname, Nachname, Adresse, Telefonnummer] \u00dcberpr\u00fcfung der Eingaben (Erlaubte Zeichen siehe Tooltip auf Label und Textboxen) Darstellung Eintr\u00e4ge werden in DataGridView dargestellt Anzahl der Eintr\u00e4ge wird angezeigt Anzahl der angezeigten Eintr\u00e4ge anpassbar Alphabetische Sortierung (Nachname, Vorname) m\u00f6glich Suchen (Felder spezifisch) Suche \u00fcber mehrere Spalten m\u00f6glich Suche mit Wildcards/Auslassungszeichen ( * ) m\u00f6glich Misc Speicherung und automatisches \u00d6ffnen der zuletzt verwendeten Datenbank Darstellung des Pfads im Forms Titel Wechseln zum Startbildschirm Datenbank Schema \u00b6 Damit bereits bestehende Datenbankdateien verwendet werden k\u00f6nnen muss die Tabelle in personalverwaltung umbenannt werden. Die Tabelle muss folgende Spalten beinhalten: first_name last_name address number email position entry retirement salary Die Spalten m\u00fcssen Typ TEXT sein und die Option Not null aktiviert haben.","title":"\u00dcbersicht"},{"location":"#projekt-ubersicht","text":"Auf dieser Seite befinden sich die Dokumentationen f\u00fcr unser SAEL Projekt: Personalverwaltung . Inhaltsverzeichnis: \u00dcbersicht C# Dokumentation SQL Dokumentation","title":"Projekt \u00dcbersicht"},{"location":"#source-code","text":"Der Source Code kann entweder direkt auf GitHub gelesen werden, oder lokal, nachdem der Source Code heruntergeladen wurde: Der Source Code kann entweder mit git clone https://github.com/DerRockWolf/SAEL_Project_Personalverwaltung.git geklont werden oder \u00fcber die Option Download ZIP ( Direct Download ) als ZIP Archiv heruntergeladen werden.","title":"Source Code"},{"location":"#build","text":"Da wir in unserem Projekt einen Teil des System.Data.SQLite NuGet-Paket verwenden muss dies zuerst geladen werden: Dies geschied automatisch beim ersten Build . Es ist aber auch m\u00f6glich das Paket zuvor wiederherzustellen: Rechtsklick auf die Projektmappe (Solution) im Projektmappen-Explorer Linksklick auf NuGet-Pakete wiederherstellen Danach kann der Source Code gelesen werden und die gelben Warndreiecke vor den Verweisen im Projektmappen-Explorer verschwinden. WICHTIG Da Visual Studio (MSBuild.exe) die ben\u00f6tigten sqlite.interop.dll Dateien beim 1. Build nicht automatisch in den Build Pfad kopiert muss wie folgt vorgegangen werden: Projektmappe bereinigen: Erstellen > Projektmappe bereinigen Projektmappe erstellen: Erstellen > Projektmappe erstellen","title":"Build"},{"location":"#features","text":"Datenspeicherung in SQLite Datenbank Erstellen neuer Datenbank-Dateien \u00d6ffnen von bestehenden Datenbank-Dateien \u00dcberpr\u00fcfung des Datenbank Schemas Ver\u00e4nderung der Daten Erstellung neuer Eintr\u00e4ge Bearbeitung von bestehenden Eintr\u00e4gen L\u00f6schen von bestehenden Eintr\u00e4gen Verhalten Pflichfelder (gekennzeichnet mit * ) [Vorname, Nachname, Adresse, Telefonnummer] \u00dcberpr\u00fcfung der Eingaben (Erlaubte Zeichen siehe Tooltip auf Label und Textboxen) Darstellung Eintr\u00e4ge werden in DataGridView dargestellt Anzahl der Eintr\u00e4ge wird angezeigt Anzahl der angezeigten Eintr\u00e4ge anpassbar Alphabetische Sortierung (Nachname, Vorname) m\u00f6glich Suchen (Felder spezifisch) Suche \u00fcber mehrere Spalten m\u00f6glich Suche mit Wildcards/Auslassungszeichen ( * ) m\u00f6glich Misc Speicherung und automatisches \u00d6ffnen der zuletzt verwendeten Datenbank Darstellung des Pfads im Forms Titel Wechseln zum Startbildschirm","title":"Features"},{"location":"#datenbank-schema","text":"Damit bereits bestehende Datenbankdateien verwendet werden k\u00f6nnen muss die Tabelle in personalverwaltung umbenannt werden. Die Tabelle muss folgende Spalten beinhalten: first_name last_name address number email position entry retirement salary Die Spalten m\u00fcssen Typ TEXT sein und die Option Not null aktiviert haben.","title":"Datenbank Schema"},{"location":"doc-OOP/","text":"OOP - Verwendete Elemente \u00b6 Klassen \u00b6 Verwendung in anderen Klassen \u00b6 Zugriffsmodifizierer \u00b6 Static \u00b6 And what not... \u00b6","title":"OOP Dokumentation"},{"location":"doc-OOP/#oop-verwendete-elemente","text":"","title":"OOP - Verwendete Elemente"},{"location":"doc-OOP/#klassen","text":"","title":"Klassen"},{"location":"doc-OOP/#verwendung-in-anderen-klassen","text":"","title":"Verwendung in anderen Klassen"},{"location":"doc-OOP/#zugriffsmodifizierer","text":"","title":"Zugriffsmodifizierer"},{"location":"doc-OOP/#static","text":"","title":"Static"},{"location":"doc-OOP/#and-what-not","text":"","title":"And what not..."},{"location":"doc-SQL/","text":"SQL - Verwendete Elemente \u00b6 Dokumentation aller verwendeten SQL Elemente. SQLite \u00b6 SQLite ist eine freie prozessintegrierte Programmbibliothek, welche eine in sich geschlossene, serverlose, konfigurationsfreie, transaktionale SQL-Datenbank-Engine ohne Server implementiert. SQLite Datenbanken sind sehr portabel, da sich alle Tabellen, etc. in einer einzigen Datei befinden. SQLite Datenbanken sind serverless , sie ben\u00f6tigen keinen Serverprozess, welcher sich zwischen der Datenbank und dem Programm befindet. Die Prozesse, die Daten lesen und schreiben greifen direkt auf die Datenbankdatei zu. Au\u00dferdem ist die Bibliothek sehr kompakt (~600 KiB) und Open Source. SQLite wird wahrscheinlich mehr als alle anderen Datenbank-Engines zusammen verwendet und hat daher eine sehr hohe Verbreitung. Bei Tabellen von SQLite Datenbanken gibt es standardm\u00e4\u00dfig immer eine Spalte rowid , welche die primary keys der Reihen darstellt. Diese Schl\u00fcssel dienen dazu eine Reihe unabh\u00e4ngig von ihrem Inhalt identifizieren zu k\u00f6nnen. Prim\u00e4r Schl\u00fcssel sind immer einzigartig und d\u00fcrfen sich nicht \u00e4ndern. SQlite Connector \u00b6 System.Data.SQLite , ein ADO.NET-Provider f\u00fcr SQLite Datenbanken, welcher auch als NuGet-Paket zu verf\u00fcgung gestellt wird und die M\u00f6glichkeit bietet mit SQLite Datenbanken zu arbeiten hat folgende Klassen und Methoden, welche wir verwendet haben: Mit der Klasse SQLiteConnection und dessen standard Constructor k\u00f6nnen die Connectoren konstruiert werden. Als Parameter wird der ConnectionString \u00fcbergeben. Mithilfe der untergeordneten Methode CreateFile kann einfach eine neue Datenbankdatei am \u00fcbergebenen Pfad erstellt werden Mit der Klasse SQLiteCommand und dem erstellten SQLiteConnection Objekt kann ein neues SQLiteCommand Objekt erzeugt werden. \u007fMit der Methode Open eines Connectors wird die Verbindung zur Datenbankdatei mithilfe der Parameter aus SQLiteConnection.ConnectionString aufgebaut. Mit der Methode Close wird die bestehende Verbindung geschlossen. Dem String SQLiteCommand.CommandText werden die SQL Queries zugewiesen. Die Methode SQLiteCommand.ExecuteReader sendet den Query an die Datenbankdatei und erzeugt eine neue SQLiteDataReader Klasse aus der Antwort. Mit der Read Methode der SQLiteDataReader Klasse wird die n\u00e4chste Reihe der Antwort gelesen. Gibt true zur\u00fcck wenn eine neue Reihe erfolgreich geladen wurde. Nach ausf\u00fchren von Read kann auf die einzelnen Spalten der Reihe mit einem Index zugegriffen werden. Mit hilfe von z.B. GetInt32 wird die Spalte als int abgerufen. SQL \u00b6 SQL (Structured Query Language) ist eine Datenbanksprache zur Definition von Datenstrukturen in realtionalen Datenbanken sowie zum Bearbeiten (Einf\u00fcgen, Ver\u00e4ndern, L\u00f6schen) und Abfragen von Daten einer relationalen Datenbank. Folgende SQL Elemente haben wir verwendet: CREATE TABLE \u00b6 CREATE TABLE CREATE TABLE table_name ( column_name1 TEXT NOT NULL , column_name2 INTEGER ); Dieser SQL String erstellt eine Tabelle mit dem Namen table_name , zwei Spalten mit den Namen column_name1 , column_name2 , den Datentypen TEXT , INTEGER und der Bedingung das Spalte column_name1 NOT NULL sein muss. SELECT \u00b6 SELECT SELECT * FROM table_name ; Ruft alle Spalten und alle Reihen der Tabelle table_name ab. Mit LIMIT 1000 werden nur die ersten 1000 Eintr\u00e4ge abgerufen. Mit SELECT COUNT(*) FROM table_name kann in einer SQLite Datenbank die Anzahl der Zeihen gez\u00e4hlt werden. WHERE \u00b6 WHERE SELECT * FROM table_name WHERE column_name1 = \"text\" ; Ruft alle Spalten und alle Reihen der Tabelle table_name ab, die in Spalte column_name1 den Inhalt text haben. Um die Suche zu verfeinern k\u00f6nnen mehrere WHERE Klauseln mit AND , OR oder NOT verkn\u00fcpft werden. ORDER BY \u00b6 ORDER BY SELECT * FROM table_name ORDER BY column_name1 , column_name2 ASC ; Dieser Query sortiert die Antwort aufsteigend, zuerst nach column_name1 und anschlie\u00dfend nach column_name2 . Um absteigend zu sortieren wird statt ASC DESC verwendet. INSERT INTO \u00b6 INSERT INTO INSERT INTO table_name ( column_name1 , column_name2 ) VALUES ( \"text\" , 42 ); F\u00fcgt eine neue Reihe in die Tabelle table_name mit text f\u00fcr column_name1 und 42 f\u00fcr column_name2 hinzu. UPDATE \u00b6 UPDATE UPDATE table_name SET column_name1 = \"TEXT\" , column_name2 = 17 WHERE rowid = 10 ; Aktualisiert die Reihe mit der rowid = 10 in der Tabelle table_name , sodass column_name TEXT beinhaltet und column_name2 17 . Hier ist es sehr wichtig nicht eine WHERE Klausel zu vergessen, da sonst alle Reihen der Tabelle mit den Werten \u00fcberschrieben werden w\u00fcrden. DELETE \u00b6 DELETE DELETE FROM table_name WHERE rowid = 11 ; L\u00f6scht die Reihe mit der rowid = 11 in der Tabelle table_name . Hier ist es ebenfalls wichtig eine WHERE Klausel zu verwenden, da sonst alle Reihen der Tabelle gel\u00f6scht werden w\u00fcrden.","title":"SQL Dokumentation"},{"location":"doc-SQL/#sql-verwendete-elemente","text":"Dokumentation aller verwendeten SQL Elemente.","title":"SQL - Verwendete Elemente"},{"location":"doc-SQL/#sqlite","text":"SQLite ist eine freie prozessintegrierte Programmbibliothek, welche eine in sich geschlossene, serverlose, konfigurationsfreie, transaktionale SQL-Datenbank-Engine ohne Server implementiert. SQLite Datenbanken sind sehr portabel, da sich alle Tabellen, etc. in einer einzigen Datei befinden. SQLite Datenbanken sind serverless , sie ben\u00f6tigen keinen Serverprozess, welcher sich zwischen der Datenbank und dem Programm befindet. Die Prozesse, die Daten lesen und schreiben greifen direkt auf die Datenbankdatei zu. Au\u00dferdem ist die Bibliothek sehr kompakt (~600 KiB) und Open Source. SQLite wird wahrscheinlich mehr als alle anderen Datenbank-Engines zusammen verwendet und hat daher eine sehr hohe Verbreitung. Bei Tabellen von SQLite Datenbanken gibt es standardm\u00e4\u00dfig immer eine Spalte rowid , welche die primary keys der Reihen darstellt. Diese Schl\u00fcssel dienen dazu eine Reihe unabh\u00e4ngig von ihrem Inhalt identifizieren zu k\u00f6nnen. Prim\u00e4r Schl\u00fcssel sind immer einzigartig und d\u00fcrfen sich nicht \u00e4ndern.","title":"SQLite"},{"location":"doc-SQL/#sqlite-connector","text":"System.Data.SQLite , ein ADO.NET-Provider f\u00fcr SQLite Datenbanken, welcher auch als NuGet-Paket zu verf\u00fcgung gestellt wird und die M\u00f6glichkeit bietet mit SQLite Datenbanken zu arbeiten hat folgende Klassen und Methoden, welche wir verwendet haben: Mit der Klasse SQLiteConnection und dessen standard Constructor k\u00f6nnen die Connectoren konstruiert werden. Als Parameter wird der ConnectionString \u00fcbergeben. Mithilfe der untergeordneten Methode CreateFile kann einfach eine neue Datenbankdatei am \u00fcbergebenen Pfad erstellt werden Mit der Klasse SQLiteCommand und dem erstellten SQLiteConnection Objekt kann ein neues SQLiteCommand Objekt erzeugt werden. \u007fMit der Methode Open eines Connectors wird die Verbindung zur Datenbankdatei mithilfe der Parameter aus SQLiteConnection.ConnectionString aufgebaut. Mit der Methode Close wird die bestehende Verbindung geschlossen. Dem String SQLiteCommand.CommandText werden die SQL Queries zugewiesen. Die Methode SQLiteCommand.ExecuteReader sendet den Query an die Datenbankdatei und erzeugt eine neue SQLiteDataReader Klasse aus der Antwort. Mit der Read Methode der SQLiteDataReader Klasse wird die n\u00e4chste Reihe der Antwort gelesen. Gibt true zur\u00fcck wenn eine neue Reihe erfolgreich geladen wurde. Nach ausf\u00fchren von Read kann auf die einzelnen Spalten der Reihe mit einem Index zugegriffen werden. Mit hilfe von z.B. GetInt32 wird die Spalte als int abgerufen.","title":"SQlite Connector"},{"location":"doc-SQL/#sql","text":"SQL (Structured Query Language) ist eine Datenbanksprache zur Definition von Datenstrukturen in realtionalen Datenbanken sowie zum Bearbeiten (Einf\u00fcgen, Ver\u00e4ndern, L\u00f6schen) und Abfragen von Daten einer relationalen Datenbank. Folgende SQL Elemente haben wir verwendet:","title":"SQL"},{"location":"doc-SQL/#create-table","text":"CREATE TABLE CREATE TABLE table_name ( column_name1 TEXT NOT NULL , column_name2 INTEGER ); Dieser SQL String erstellt eine Tabelle mit dem Namen table_name , zwei Spalten mit den Namen column_name1 , column_name2 , den Datentypen TEXT , INTEGER und der Bedingung das Spalte column_name1 NOT NULL sein muss.","title":"CREATE TABLE"},{"location":"doc-SQL/#select","text":"SELECT SELECT * FROM table_name ; Ruft alle Spalten und alle Reihen der Tabelle table_name ab. Mit LIMIT 1000 werden nur die ersten 1000 Eintr\u00e4ge abgerufen. Mit SELECT COUNT(*) FROM table_name kann in einer SQLite Datenbank die Anzahl der Zeihen gez\u00e4hlt werden.","title":"SELECT"},{"location":"doc-SQL/#where","text":"WHERE SELECT * FROM table_name WHERE column_name1 = \"text\" ; Ruft alle Spalten und alle Reihen der Tabelle table_name ab, die in Spalte column_name1 den Inhalt text haben. Um die Suche zu verfeinern k\u00f6nnen mehrere WHERE Klauseln mit AND , OR oder NOT verkn\u00fcpft werden.","title":"WHERE"},{"location":"doc-SQL/#order-by","text":"ORDER BY SELECT * FROM table_name ORDER BY column_name1 , column_name2 ASC ; Dieser Query sortiert die Antwort aufsteigend, zuerst nach column_name1 und anschlie\u00dfend nach column_name2 . Um absteigend zu sortieren wird statt ASC DESC verwendet.","title":"ORDER BY"},{"location":"doc-SQL/#insert-into","text":"INSERT INTO INSERT INTO table_name ( column_name1 , column_name2 ) VALUES ( \"text\" , 42 ); F\u00fcgt eine neue Reihe in die Tabelle table_name mit text f\u00fcr column_name1 und 42 f\u00fcr column_name2 hinzu.","title":"INSERT INTO"},{"location":"doc-SQL/#update","text":"UPDATE UPDATE table_name SET column_name1 = \"TEXT\" , column_name2 = 17 WHERE rowid = 10 ; Aktualisiert die Reihe mit der rowid = 10 in der Tabelle table_name , sodass column_name TEXT beinhaltet und column_name2 17 . Hier ist es sehr wichtig nicht eine WHERE Klausel zu vergessen, da sonst alle Reihen der Tabelle mit den Werten \u00fcberschrieben werden w\u00fcrden.","title":"UPDATE"},{"location":"doc-SQL/#delete","text":"DELETE DELETE FROM table_name WHERE rowid = 11 ; L\u00f6scht die Reihe mit der rowid = 11 in der Tabelle table_name . Hier ist es ebenfalls wichtig eine WHERE Klausel zu verwenden, da sonst alle Reihen der Tabelle gel\u00f6scht werden w\u00fcrden.","title":"DELETE"},{"location":"doc-cSharp/","text":"C# - Verwendete Elemente \u00b6 Dokumentation aller verwendeten Elemente aus C# mitsamt Codebeispielen (Verwendete OOP Elemente ) Verzweigungen (Conditional Statements) \u00b6 Mithilfe von Verzweigungen k\u00f6nnen verschieden Programmabschnitte unter bestimmten Bedingungen ausgef\u00fchrt werden. IF & ELSE \u00b6 Verzweigungen innerhalb eines Programms werden durch Bedingungen entschieden. Diese Bedingungen k\u00f6nnen mit IF & ELSE realisiert werden. Im Folgegeneden Code-Beispiel wird \u00fcberpr\u00fcft, ob die Variable Integer den Wert '8' enh\u00e4lt. Wenn diese Bedingung zutrifft, wird der sogenannte IF-Codeblock ausgef\u00fchrt und dieser gibt anschlie\u00dfend in einer MessageBox den Text \"Die Zahl hat den Wert '8'\" aus. IF-Bedingung \u00b6 C# var Integer = 8 ; if ( Integer == 8 ) { MessageBox . Show ( \"Die Zahl hat den Wert '8' \" ) } Ausgabe : \"Die Zahl hat den Wert '8' \" ELSE-Bedingung \u00b6 else kann benutzt werden, um festzulegen, welcher Code-Block ausgef\u00fchrt wird, wenn die vorherige IF-Bedingung false ist. C# var Integer = 6 ; if ( Integer == 6 ) { MessageBox . Show ( \"Die Zahl hat den Wert '8'.\" ) } else { MessageBox . Show ( \"Die Zahl hat nicht den Wert '8'.\" ) } Ausgabe : \"Die Zahl hat nicht den Wert '8'.\" ELSE IF'-Bedingung \u00b6 Falls eine zus\u00e4tzliche Bedingung neben der IF-Bedingung hinzugef\u00fcgt werden soll, kann dies mit Else if realisiert werden. C# var Integer = 1 ; if ( Integer == 8 ) { MessageBox . Show ( \"Die Zahl hat den Wert '8'.\" ) } else if ( Integer == 1 ) { MessageBox . Show ( \"Die Zahl hat den Wert '1'.\" ) } Ausgabe : \"Die Zahl hat den Wert '1'.\" Um in den IF & ELSE-Bedingungen z.B mehrere Werte abzufragen, gibt es die M\u00f6glichkeit, AND und OR Operatoren zu verwenden. Hier zu k\u00f6nnen Sie im \"Kopf\" der IF & ELSE-Bedingung die folgenden Zeichen angeben: | f\u00fcr OR/oder und & f\u00fcr AND/und. Wie Sie die Operatoren im Programmcode implementieren, sehen Sie im n\u00e4chsten Code-Beispiel. Gesamter If-Block-Bedingung \u00b6 Ein If-Else Codeblock k\u00f6nnte dann zum Beispiel so aussehen: C# var Integer = 4 ; if ( Integer == 8 ) { MessageBox . Show ( \"Die Zahl hat den Wert '8'.\" ) } else if ( Integer == 1 | Integer == 7 ) { MessageBox . Show ( \"Die Zahl hat entweder den Wert '1' oder '7'.\" ) } else { MessageBox . Show ( \"Die Zahl hat weder den Wert '1' noch den Wert '8'.\" ) } Ausgabe : \"Die Zahl hat weder die Werte '1', '7' noch den Wert '8'.\" Switch Case \u00b6 Eine andere M\u00f6glichkeit, um Bedingungen zu realisieren, ist das sogenannte Switch Case . Der Vorteile von Switch Case gegen\u00fcber If-Else sind, dass jenes ab f\u00fcnf Bedingungen effizierter, schneller und \u00fcbersichtlicher ist. Die Switch Case Syntax ist wie folgend: C# var Integer = 5 ; switch ( Integer ) { case \"0\" : MessageBox . Show ( \"Die Zahl hat den Wert '0'.\" ) break ; case \"1\" : MessageBox . Show ( \"Die Zahl hat den Wert '1'.\" ) break ; case \"2\" : MessageBox . Show ( \"Die Zahl hat den Wert '2'.\" ) break ; case \"3\" : MessageBox . Show ( \"Die Zahl hat den Wert '3'.\" ) break ; case \"4\" : MessageBox . Show ( \"Die Zahl hat den Wert '4'.\" ) break ; case \"5\" : MessageBox . Show ( \"Die Zahl hat den Wert '5'.\" ) break ; case \"6\" : MessageBox . Show ( \"Die Zahl hat den Wert '6'.\" ) break ; Ausgabe : \"Die Zahl hat den Wert 5\" } Ausnahmen (Exceptions) \u00b6 Try Catch \u00b6 Um Programmabst\u00fcrze zu vermeiden, kann Try & Catch (Versuchen & (ab)fangen) verwendet werden. Mit diesem ist es m\u00f6glich, den Programmfehler und den damit verbunden stop der Anwendung zu verhindern und z. B. eine eigene Fehlerbehandlung zu implementieren. Hier Beispiel, wie Try & Catch im Programmcode eingesetzt werden k\u00f6nnte: C# try { // Code, der ausgef\u00fchrt werden soll. } catch { // M\u00f6gliche Fehlerbehandlung. } Schleifen (Loops) \u00b6 Schleifen f\u00fchren einen bestimmten Code-Block so lange aus, bis eine angegebene Bedingung erreicht ist. Es gibt drei verschiedene Arten von Schleifen: Nicht abweisende Schleifen. Beispiel: die do-while -Schleife. Abweisende Schleifen. Beispiel: die while -Schleife. Z\u00e4hlschleifen. Beispiel: die for -Schleife. do while-Schleifen \u00b6 Die do while ist eine fu\u00dfgesteuerte Schleife, dass bedeutet, dass die angegebene Bedingung erst am Ende (\"Fu\u00df\") der Schleife \u00fcberpr\u00fcft wird. C# var Integer = 1 ; do { Integer ++; } while ( integer < 10 ) Das Programm wird die Schleife verlassen, nachdem die Variable Integer den Wert '10' erreicht hat und dadurch die Bedingung nicht mehr erf\u00fcllt wird. while-Schleifen \u00b6 C# var Integer = 1 ; while ( integer < 10 ) { Integer ++; } Die Schleife wird verlassen, nachdem die Variable den Wert '10' erreicht hat und dadurch die Bedingung nicht mehr wahr ist ( '10' ist nicht kleiner als '10' ) for-Schleifen \u00b6 Die for ist eine Z\u00e4hlschleife. Diese eignet sich gut, um z. B. Variablen hoch- oder herunter zu z\u00e4hlen. Im Schleifenkopf wird die zu \u00fcberpr\u00fcfende Variable initialisiert, die Bedingung angegeben und zus\u00e4tzlich wird festgelegt, was in den Schleifendurchl\u00e4ufen mit der Variable geschieht (z. B. der Wert wird jeweils um 1 erh\u00f6ht). C# for ( var integer = 1 ; integer < 10 ; integer ++) { // Hier kann z. B. der derzeitige Wert der Variable ausgegeben werden. Console . WriteLine ( integer ); } Nachdem die Variable den Wert '10' erreicht hat, wird der Schleifen-Codeblock nicht mehr ausgef\u00fchrt und dadurch ist die letzte Zahl, die ausgegeben wird der Integer '9' . Datenstrukturen \u00b6 Datenstrukturen erm\u00f6glichen das strukturierte Speicherung und Abrufen von Daten. Arrays \u00b6 Arrays k\u00f6nnen verwendet werden, um mehrere Variablenwerte in einer einzelnen Variable zu speichern, um damit zu umgehen, dass jeder Wert einzeln deklariert werden muss. So kann man zum Beispiel einen (eindimensionalen) Array mit der Gr\u00f6\u00dfe '5' zu deklarieren und initialisieren: C# int [] integer = new int [ 5 ]; So k\u00f6nnte man einem Array einzelne Werte zuweisen: C# integer [ 0 ] = 54 ; integer [ 1 ] = 13 ; Es ist auch m\u00f6glich, dem Array seine Werte direkt bei der Deklarierung zuzuweisen: C# int [] integer = { 45 , 3 , 54 , 13 , 43 }; Mehrdimensionale Arrays \u00b6 Es gibt auch die M\u00f6glichkeit, einen mehrdimensionalen Array zu erstellen. Mehrdimensional bedeutet, dass in dem Array nun in den einzelnen Spalten mehrere Werte eingespeichert werden k\u00f6nnen. Um einen Mehrdimensionalen Array zu erzeugen, muss lediglich bei der Initialisierung in den ersten eckigen Klammern ein Komma gesetzt werden. Hier ein Code-Beispiel: C# int [,] integer = new int [ 5 , 3 ]; Der Array hat nun sechs Spalten in denen bis zu vier Werte eingespeichet werden k\u00f6nnen. Warum sechs Spalten und vier Werte? Antwort : Das liegt daran, dass Arrays nullbasierend sind. Das bedeutet, dass der Array den ersten Variablenwert mit dem Index '0' einspeichert. Deshalb ist der reelle Wert des Arrays immer um einen Integer erh\u00f6ht. So k\u00f6nnte dann zum Beispiel ein Wert in einem mehrdimensionalen Array eingespeichert werden: C# integer [ 0 , 0 ] = 45 ; integer [ 0 , 1 ] = 21 ; Um die Gr\u00f6\u00dfe eines Array flexibel zu gestalten, gibt es die M\u00f6glichkeit, ihn mithilfe von Variablen zu deklarieren und zus\u00e4tzlich mit Ihnen das Einspeichern von einzelnen Werten zu \u00fcbernehmen. C# int a = 78 ; int b = 43 ; int c = 0 ; int d = 1 ; int [,] integer = [ a , b ]; integer [ c , d ] = 13 ; Die Variablen k\u00f6nnen dann innerhalb des Programmcodes ver\u00e4ndert werden und dadurch die Gr\u00f6\u00dfe des Array und die eingespeicherten Werte beeinflussen. Listen \u00b6 In Listen k\u00f6nnen wie in einem Array mehrere Variablenwerte eingespeichert werden. Sie kann wie folgend deklariert werden: C# List < string > Buchstaben = new List < string >() Um einer Liste einen Wert zuzuweisen, kann man dies z. B. wie in diesem Code-Beispiel tun: C# Buchstaben . Add ( \"A\" ) Buchstaben . Add ( \"B\" ) So k\u00f6nnen Sie die Werte einer Liste auszugeben: C# Console . WriteLine ( Buchstaben [ 0 ]) Ausgabe : \"A\" //Es wird der Wert ausgegeben, welcher als Erstes der Liste hinzugef\u00fcgt wurde. Methoden/Funktionen \u00b6 Grundlagen \u00b6 Methoden werden verwendet, um bestimmte Aktionen im Programmcode auszuf\u00fchren, Sie werden auch als Funktionen bezeichnet. Der Vorteil an Methoden ist, dass Sie mehrmals verwendet werden k\u00f6nnen. Dadurch kann vermieden werden, den gleichen Code mehrmals zu verfassen und stattdessen eine Methode, die auch diesen Code enth\u00e4lt, aufzurufen. Info Es gibt in C# auch vorprogrammierte Methoden. Bekannte Vertreter hiervon sind: Console.WriteLine oder MessageBox.Show In diesem Code-Beispiel wird ihnen nun gezeigt, wie Sie eine eigene Methode erstellen k\u00f6nnen. C# void TestMethode () { // Programmcode der in der Methode ausgef\u00fchrt werden soll. } Um diese Methode anschlie\u00dfend im Programm aufzurufen, gehen Sie wie folgend vor: C# static void Main ( string [] args ) { TestMethode (); } void TestMethode () { MessageBox . Show ( \"das ist ein Test!\" ) } Ausgabe : \"Das ist ein Test\" Methoden mit Argumenten \u00b6 Es gibt die M\u00f6glichkeit, einer Methode aus dem Programmcode heraus Information mitzugeben. In C# werden diese Information Argumente genannt. Diese Argumente k\u00f6nnen beim Aufruf der Methode in den Klammern mitgegeben werden und anschlie\u00dfend wird im Kopf der Methode angeben, als welchen Datentyp und mit welchem Namen die Methode das mitgegebene Argument verarbeiten soll. Hier ein Code-Beispiel zu Argumenten: C# static void Main ( string [] args ) { TestMethode ( \"Hallo\" ); } void TestMethode ( string Begr\u00fc\u00dfung ) { MessageBox . Show ( Begr\u00fc\u00dfung + \"das ist ein Test!\" ) } Ausgabe : \"Hallo das ist ein Test!\" In diesem Beispiel wird der Methode die Zeichenfolge \"Hallo\" als Argument \u00fcbergeben. Die Methode verarbeitet das Argument als string und gibt diesem den Namen Begr\u00fc\u00dfung . Anschlie\u00dfend werden der string Begr\u00fc\u00dfung und die Zeichenfolge \"das ist ein Test!\" in einer MessageBox ausgegeben. Es nat\u00fcrlich auch m\u00f6glich, mehrere Argumente anzugeben, diese m\u00fcssen jedoch mit einem Komma getrennt werden: C# static void Main ( string [] args ) { TestMethode ( \"Hallo\" , \"Max\" ); } void TestMethode ( string Begr\u00fc\u00dfung , string Name ) { MessageBox . Show ( Begr\u00fc\u00dfung + Name + \"das ist ein Test!\" ) } Ausgabe : \"Hallo Max das ist ein Test!\" Argumente per Referenz \u00fcbergeben \u00b6 Wenn Sie einer Methode eine Variable per Argument \u00fcbergeben, werden diese Variablen sozusagen kopiert und anschlie\u00dfend im Methoden-Cope verwendet. Falls diese \"kopierten\" Variablen in der Methode ver\u00e4ndert werden, hat dies keine Auswirkung auf das Original. Diese Variable bleibt unver\u00e4ndert. Wenn Sie jedoch m\u00f6chten, dass die Ver\u00e4nderung in der Methode Auswirkungen auf das Original zeigt, k\u00f6nnen Sie die per Referenz und dem Schl\u00fcsselwort ref tun. Hier ein Code-Beispiel: C# mit Referenz int x = 5 ; int y = 2 ; static void Main ( string [] args ) { TestMethode ( ref x , ref y ); MessageBox . Show ( x , y ) } /* Die Variablen 'x' und 'y' werden der Methode als Variable 'a' und 'b' \u00fcbergeben. */ void TestMethode ( ref int a , ref int b ) { x = 19 ; y = 3 ; } Ausgabe : x = 19 \"und\" y = 3 ; C# ohne Referenz int x = 5 ; int y = 2 ; static void Main ( string [] args ) { TestMethode ( x , y ); MessageBox . Show ( x , y ) } /* Die Variablen 'x' und 'y' werden der Methode als Variable 'a' und 'b' \u00fcbergeben. */ void TestMethode ( int a , int b ) { a = 19 ; b = 3 ; } Ausgabe : x = 5 \"und\" y = 2 ; Methoden mit R\u00fcckgabewert \u00b6 Die vorherigen Methode-Beispiele hatten alle den Datentyp void . Mit diesem ist es nur indirekt m\u00f6glich, Wert zur\u00fcckzugeben. Wenn die Methode jedoch mit einem Datentyp wie zum Beispiel int oder double deklariert wird, ist es \u00fcber das Schl\u00fcsselwort return m\u00f6glich, einen R\u00fcckgabewert zu erhalten. Wie dies m\u00f6glich ist, sehen Sie im folgenden Code-Beispiel: C# int x = 8 ; int y = 5 ; int z = Gr\u00f6\u00dfterWert ( x , y ); static void Main ( string [] args ) { Gr\u00f6\u00dfterWert ( x , y ); MessageBox . Show ( \"Die gr\u00f6\u00dfte Zahl ist: \" + z ); } static int Gr\u00f6\u00dfterWert ( int a , int b ) { if ( a > b ) { return a ; } else { return b ; } } Ausgabe : \"Die gr\u00f6\u00dfte Zahl ist: 8\" In diesem Beispiel werden der Methode Gr\u00f6\u00dfterWert die beiden Variablen x und y \u00fcbergeben. Die Methode ermittelt anschlie\u00dfend, welcher der beiden Werte gr\u00f6\u00dfer ist und \u00fcbergibt je nachdem den gr\u00f6\u00dften Wert. Dieser wird darauffolgend als Variable z in einer MessageBox ausgegeben. FileWriter/FileReader \u00b6 Mit Hilfe des FileWriter und des FileReader ist es m\u00f6glich, Textdateien zu erstellen und diese bei Start des Programms einzulesen. File Writer \u00b6 Mit dem File Writer ist es m\u00f6glich, einen Dateipfad f\u00fcr eine Textdatei anzugeben und dann den Inhalt der Datei zu bestimmen. Hier folgendes Code-Beispiel: C# string DateiPfad = \"C:\\tmp\\Test.txt\" ; string Inhalt = \"Test\" ; File . WriteAllText ( DateiPfad , Inhalt ); In diesem Beispiel wird als Pfad \"C:\\tmp\\Test.txt\" angegeben. In die Textdatei wird dann ein String mit der Zeichenfolge \"Test\" hineingeschrieben. File Reader \u00b6 Mit Hilfe des File Reader ist es im Anschluss m\u00f6glich, die gespeicherte Textdatei wieder im Programm einzulesen und zum Beispiel einer Variable zuzuweisen. C# string DateiPfad = \"C:\\tmp\\Test.txt\" ; string Inhalt = \"\" ; Inhalt = File . ReadAllText ( DateiPfad );","title":"C# Dokumentation"},{"location":"doc-cSharp/#c-verwendete-elemente","text":"Dokumentation aller verwendeten Elemente aus C# mitsamt Codebeispielen (Verwendete OOP Elemente )","title":"C# - Verwendete Elemente"},{"location":"doc-cSharp/#verzweigungen-conditional-statements","text":"Mithilfe von Verzweigungen k\u00f6nnen verschieden Programmabschnitte unter bestimmten Bedingungen ausgef\u00fchrt werden.","title":"Verzweigungen (Conditional Statements)"},{"location":"doc-cSharp/#if-else","text":"Verzweigungen innerhalb eines Programms werden durch Bedingungen entschieden. Diese Bedingungen k\u00f6nnen mit IF & ELSE realisiert werden. Im Folgegeneden Code-Beispiel wird \u00fcberpr\u00fcft, ob die Variable Integer den Wert '8' enh\u00e4lt. Wenn diese Bedingung zutrifft, wird der sogenannte IF-Codeblock ausgef\u00fchrt und dieser gibt anschlie\u00dfend in einer MessageBox den Text \"Die Zahl hat den Wert '8'\" aus.","title":"IF &amp; ELSE"},{"location":"doc-cSharp/#if-bedingung","text":"C# var Integer = 8 ; if ( Integer == 8 ) { MessageBox . Show ( \"Die Zahl hat den Wert '8' \" ) } Ausgabe : \"Die Zahl hat den Wert '8' \"","title":"IF-Bedingung"},{"location":"doc-cSharp/#else-bedingung","text":"else kann benutzt werden, um festzulegen, welcher Code-Block ausgef\u00fchrt wird, wenn die vorherige IF-Bedingung false ist. C# var Integer = 6 ; if ( Integer == 6 ) { MessageBox . Show ( \"Die Zahl hat den Wert '8'.\" ) } else { MessageBox . Show ( \"Die Zahl hat nicht den Wert '8'.\" ) } Ausgabe : \"Die Zahl hat nicht den Wert '8'.\"","title":"ELSE-Bedingung"},{"location":"doc-cSharp/#else-if-bedingung","text":"Falls eine zus\u00e4tzliche Bedingung neben der IF-Bedingung hinzugef\u00fcgt werden soll, kann dies mit Else if realisiert werden. C# var Integer = 1 ; if ( Integer == 8 ) { MessageBox . Show ( \"Die Zahl hat den Wert '8'.\" ) } else if ( Integer == 1 ) { MessageBox . Show ( \"Die Zahl hat den Wert '1'.\" ) } Ausgabe : \"Die Zahl hat den Wert '1'.\" Um in den IF & ELSE-Bedingungen z.B mehrere Werte abzufragen, gibt es die M\u00f6glichkeit, AND und OR Operatoren zu verwenden. Hier zu k\u00f6nnen Sie im \"Kopf\" der IF & ELSE-Bedingung die folgenden Zeichen angeben: | f\u00fcr OR/oder und & f\u00fcr AND/und. Wie Sie die Operatoren im Programmcode implementieren, sehen Sie im n\u00e4chsten Code-Beispiel.","title":"ELSE IF'-Bedingung"},{"location":"doc-cSharp/#gesamter-if-block-bedingung","text":"Ein If-Else Codeblock k\u00f6nnte dann zum Beispiel so aussehen: C# var Integer = 4 ; if ( Integer == 8 ) { MessageBox . Show ( \"Die Zahl hat den Wert '8'.\" ) } else if ( Integer == 1 | Integer == 7 ) { MessageBox . Show ( \"Die Zahl hat entweder den Wert '1' oder '7'.\" ) } else { MessageBox . Show ( \"Die Zahl hat weder den Wert '1' noch den Wert '8'.\" ) } Ausgabe : \"Die Zahl hat weder die Werte '1', '7' noch den Wert '8'.\"","title":"Gesamter If-Block-Bedingung"},{"location":"doc-cSharp/#switch-case","text":"Eine andere M\u00f6glichkeit, um Bedingungen zu realisieren, ist das sogenannte Switch Case . Der Vorteile von Switch Case gegen\u00fcber If-Else sind, dass jenes ab f\u00fcnf Bedingungen effizierter, schneller und \u00fcbersichtlicher ist. Die Switch Case Syntax ist wie folgend: C# var Integer = 5 ; switch ( Integer ) { case \"0\" : MessageBox . Show ( \"Die Zahl hat den Wert '0'.\" ) break ; case \"1\" : MessageBox . Show ( \"Die Zahl hat den Wert '1'.\" ) break ; case \"2\" : MessageBox . Show ( \"Die Zahl hat den Wert '2'.\" ) break ; case \"3\" : MessageBox . Show ( \"Die Zahl hat den Wert '3'.\" ) break ; case \"4\" : MessageBox . Show ( \"Die Zahl hat den Wert '4'.\" ) break ; case \"5\" : MessageBox . Show ( \"Die Zahl hat den Wert '5'.\" ) break ; case \"6\" : MessageBox . Show ( \"Die Zahl hat den Wert '6'.\" ) break ; Ausgabe : \"Die Zahl hat den Wert 5\" }","title":"Switch Case"},{"location":"doc-cSharp/#ausnahmen-exceptions","text":"","title":"Ausnahmen (Exceptions)"},{"location":"doc-cSharp/#try-catch","text":"Um Programmabst\u00fcrze zu vermeiden, kann Try & Catch (Versuchen & (ab)fangen) verwendet werden. Mit diesem ist es m\u00f6glich, den Programmfehler und den damit verbunden stop der Anwendung zu verhindern und z. B. eine eigene Fehlerbehandlung zu implementieren. Hier Beispiel, wie Try & Catch im Programmcode eingesetzt werden k\u00f6nnte: C# try { // Code, der ausgef\u00fchrt werden soll. } catch { // M\u00f6gliche Fehlerbehandlung. }","title":"Try Catch"},{"location":"doc-cSharp/#schleifen-loops","text":"Schleifen f\u00fchren einen bestimmten Code-Block so lange aus, bis eine angegebene Bedingung erreicht ist. Es gibt drei verschiedene Arten von Schleifen: Nicht abweisende Schleifen. Beispiel: die do-while -Schleife. Abweisende Schleifen. Beispiel: die while -Schleife. Z\u00e4hlschleifen. Beispiel: die for -Schleife.","title":"Schleifen (Loops)"},{"location":"doc-cSharp/#do-while-schleifen","text":"Die do while ist eine fu\u00dfgesteuerte Schleife, dass bedeutet, dass die angegebene Bedingung erst am Ende (\"Fu\u00df\") der Schleife \u00fcberpr\u00fcft wird. C# var Integer = 1 ; do { Integer ++; } while ( integer < 10 ) Das Programm wird die Schleife verlassen, nachdem die Variable Integer den Wert '10' erreicht hat und dadurch die Bedingung nicht mehr erf\u00fcllt wird.","title":"do while-Schleifen"},{"location":"doc-cSharp/#while-schleifen","text":"C# var Integer = 1 ; while ( integer < 10 ) { Integer ++; } Die Schleife wird verlassen, nachdem die Variable den Wert '10' erreicht hat und dadurch die Bedingung nicht mehr wahr ist ( '10' ist nicht kleiner als '10' )","title":"while-Schleifen"},{"location":"doc-cSharp/#for-schleifen","text":"Die for ist eine Z\u00e4hlschleife. Diese eignet sich gut, um z. B. Variablen hoch- oder herunter zu z\u00e4hlen. Im Schleifenkopf wird die zu \u00fcberpr\u00fcfende Variable initialisiert, die Bedingung angegeben und zus\u00e4tzlich wird festgelegt, was in den Schleifendurchl\u00e4ufen mit der Variable geschieht (z. B. der Wert wird jeweils um 1 erh\u00f6ht). C# for ( var integer = 1 ; integer < 10 ; integer ++) { // Hier kann z. B. der derzeitige Wert der Variable ausgegeben werden. Console . WriteLine ( integer ); } Nachdem die Variable den Wert '10' erreicht hat, wird der Schleifen-Codeblock nicht mehr ausgef\u00fchrt und dadurch ist die letzte Zahl, die ausgegeben wird der Integer '9' .","title":"for-Schleifen"},{"location":"doc-cSharp/#datenstrukturen","text":"Datenstrukturen erm\u00f6glichen das strukturierte Speicherung und Abrufen von Daten.","title":"Datenstrukturen"},{"location":"doc-cSharp/#arrays","text":"Arrays k\u00f6nnen verwendet werden, um mehrere Variablenwerte in einer einzelnen Variable zu speichern, um damit zu umgehen, dass jeder Wert einzeln deklariert werden muss. So kann man zum Beispiel einen (eindimensionalen) Array mit der Gr\u00f6\u00dfe '5' zu deklarieren und initialisieren: C# int [] integer = new int [ 5 ]; So k\u00f6nnte man einem Array einzelne Werte zuweisen: C# integer [ 0 ] = 54 ; integer [ 1 ] = 13 ; Es ist auch m\u00f6glich, dem Array seine Werte direkt bei der Deklarierung zuzuweisen: C# int [] integer = { 45 , 3 , 54 , 13 , 43 };","title":"Arrays"},{"location":"doc-cSharp/#mehrdimensionale-arrays","text":"Es gibt auch die M\u00f6glichkeit, einen mehrdimensionalen Array zu erstellen. Mehrdimensional bedeutet, dass in dem Array nun in den einzelnen Spalten mehrere Werte eingespeichert werden k\u00f6nnen. Um einen Mehrdimensionalen Array zu erzeugen, muss lediglich bei der Initialisierung in den ersten eckigen Klammern ein Komma gesetzt werden. Hier ein Code-Beispiel: C# int [,] integer = new int [ 5 , 3 ]; Der Array hat nun sechs Spalten in denen bis zu vier Werte eingespeichet werden k\u00f6nnen. Warum sechs Spalten und vier Werte? Antwort : Das liegt daran, dass Arrays nullbasierend sind. Das bedeutet, dass der Array den ersten Variablenwert mit dem Index '0' einspeichert. Deshalb ist der reelle Wert des Arrays immer um einen Integer erh\u00f6ht. So k\u00f6nnte dann zum Beispiel ein Wert in einem mehrdimensionalen Array eingespeichert werden: C# integer [ 0 , 0 ] = 45 ; integer [ 0 , 1 ] = 21 ; Um die Gr\u00f6\u00dfe eines Array flexibel zu gestalten, gibt es die M\u00f6glichkeit, ihn mithilfe von Variablen zu deklarieren und zus\u00e4tzlich mit Ihnen das Einspeichern von einzelnen Werten zu \u00fcbernehmen. C# int a = 78 ; int b = 43 ; int c = 0 ; int d = 1 ; int [,] integer = [ a , b ]; integer [ c , d ] = 13 ; Die Variablen k\u00f6nnen dann innerhalb des Programmcodes ver\u00e4ndert werden und dadurch die Gr\u00f6\u00dfe des Array und die eingespeicherten Werte beeinflussen.","title":"Mehrdimensionale Arrays"},{"location":"doc-cSharp/#listen","text":"In Listen k\u00f6nnen wie in einem Array mehrere Variablenwerte eingespeichert werden. Sie kann wie folgend deklariert werden: C# List < string > Buchstaben = new List < string >() Um einer Liste einen Wert zuzuweisen, kann man dies z. B. wie in diesem Code-Beispiel tun: C# Buchstaben . Add ( \"A\" ) Buchstaben . Add ( \"B\" ) So k\u00f6nnen Sie die Werte einer Liste auszugeben: C# Console . WriteLine ( Buchstaben [ 0 ]) Ausgabe : \"A\" //Es wird der Wert ausgegeben, welcher als Erstes der Liste hinzugef\u00fcgt wurde.","title":"Listen"},{"location":"doc-cSharp/#methodenfunktionen","text":"","title":"Methoden/Funktionen"},{"location":"doc-cSharp/#grundlagen","text":"Methoden werden verwendet, um bestimmte Aktionen im Programmcode auszuf\u00fchren, Sie werden auch als Funktionen bezeichnet. Der Vorteil an Methoden ist, dass Sie mehrmals verwendet werden k\u00f6nnen. Dadurch kann vermieden werden, den gleichen Code mehrmals zu verfassen und stattdessen eine Methode, die auch diesen Code enth\u00e4lt, aufzurufen. Info Es gibt in C# auch vorprogrammierte Methoden. Bekannte Vertreter hiervon sind: Console.WriteLine oder MessageBox.Show In diesem Code-Beispiel wird ihnen nun gezeigt, wie Sie eine eigene Methode erstellen k\u00f6nnen. C# void TestMethode () { // Programmcode der in der Methode ausgef\u00fchrt werden soll. } Um diese Methode anschlie\u00dfend im Programm aufzurufen, gehen Sie wie folgend vor: C# static void Main ( string [] args ) { TestMethode (); } void TestMethode () { MessageBox . Show ( \"das ist ein Test!\" ) } Ausgabe : \"Das ist ein Test\"","title":"Grundlagen"},{"location":"doc-cSharp/#methoden-mit-argumenten","text":"Es gibt die M\u00f6glichkeit, einer Methode aus dem Programmcode heraus Information mitzugeben. In C# werden diese Information Argumente genannt. Diese Argumente k\u00f6nnen beim Aufruf der Methode in den Klammern mitgegeben werden und anschlie\u00dfend wird im Kopf der Methode angeben, als welchen Datentyp und mit welchem Namen die Methode das mitgegebene Argument verarbeiten soll. Hier ein Code-Beispiel zu Argumenten: C# static void Main ( string [] args ) { TestMethode ( \"Hallo\" ); } void TestMethode ( string Begr\u00fc\u00dfung ) { MessageBox . Show ( Begr\u00fc\u00dfung + \"das ist ein Test!\" ) } Ausgabe : \"Hallo das ist ein Test!\" In diesem Beispiel wird der Methode die Zeichenfolge \"Hallo\" als Argument \u00fcbergeben. Die Methode verarbeitet das Argument als string und gibt diesem den Namen Begr\u00fc\u00dfung . Anschlie\u00dfend werden der string Begr\u00fc\u00dfung und die Zeichenfolge \"das ist ein Test!\" in einer MessageBox ausgegeben. Es nat\u00fcrlich auch m\u00f6glich, mehrere Argumente anzugeben, diese m\u00fcssen jedoch mit einem Komma getrennt werden: C# static void Main ( string [] args ) { TestMethode ( \"Hallo\" , \"Max\" ); } void TestMethode ( string Begr\u00fc\u00dfung , string Name ) { MessageBox . Show ( Begr\u00fc\u00dfung + Name + \"das ist ein Test!\" ) } Ausgabe : \"Hallo Max das ist ein Test!\"","title":"Methoden mit Argumenten"},{"location":"doc-cSharp/#argumente-per-referenz-ubergeben","text":"Wenn Sie einer Methode eine Variable per Argument \u00fcbergeben, werden diese Variablen sozusagen kopiert und anschlie\u00dfend im Methoden-Cope verwendet. Falls diese \"kopierten\" Variablen in der Methode ver\u00e4ndert werden, hat dies keine Auswirkung auf das Original. Diese Variable bleibt unver\u00e4ndert. Wenn Sie jedoch m\u00f6chten, dass die Ver\u00e4nderung in der Methode Auswirkungen auf das Original zeigt, k\u00f6nnen Sie die per Referenz und dem Schl\u00fcsselwort ref tun. Hier ein Code-Beispiel: C# mit Referenz int x = 5 ; int y = 2 ; static void Main ( string [] args ) { TestMethode ( ref x , ref y ); MessageBox . Show ( x , y ) } /* Die Variablen 'x' und 'y' werden der Methode als Variable 'a' und 'b' \u00fcbergeben. */ void TestMethode ( ref int a , ref int b ) { x = 19 ; y = 3 ; } Ausgabe : x = 19 \"und\" y = 3 ; C# ohne Referenz int x = 5 ; int y = 2 ; static void Main ( string [] args ) { TestMethode ( x , y ); MessageBox . Show ( x , y ) } /* Die Variablen 'x' und 'y' werden der Methode als Variable 'a' und 'b' \u00fcbergeben. */ void TestMethode ( int a , int b ) { a = 19 ; b = 3 ; } Ausgabe : x = 5 \"und\" y = 2 ;","title":"Argumente per Referenz \u00fcbergeben"},{"location":"doc-cSharp/#methoden-mit-ruckgabewert","text":"Die vorherigen Methode-Beispiele hatten alle den Datentyp void . Mit diesem ist es nur indirekt m\u00f6glich, Wert zur\u00fcckzugeben. Wenn die Methode jedoch mit einem Datentyp wie zum Beispiel int oder double deklariert wird, ist es \u00fcber das Schl\u00fcsselwort return m\u00f6glich, einen R\u00fcckgabewert zu erhalten. Wie dies m\u00f6glich ist, sehen Sie im folgenden Code-Beispiel: C# int x = 8 ; int y = 5 ; int z = Gr\u00f6\u00dfterWert ( x , y ); static void Main ( string [] args ) { Gr\u00f6\u00dfterWert ( x , y ); MessageBox . Show ( \"Die gr\u00f6\u00dfte Zahl ist: \" + z ); } static int Gr\u00f6\u00dfterWert ( int a , int b ) { if ( a > b ) { return a ; } else { return b ; } } Ausgabe : \"Die gr\u00f6\u00dfte Zahl ist: 8\" In diesem Beispiel werden der Methode Gr\u00f6\u00dfterWert die beiden Variablen x und y \u00fcbergeben. Die Methode ermittelt anschlie\u00dfend, welcher der beiden Werte gr\u00f6\u00dfer ist und \u00fcbergibt je nachdem den gr\u00f6\u00dften Wert. Dieser wird darauffolgend als Variable z in einer MessageBox ausgegeben.","title":"Methoden mit R\u00fcckgabewert"},{"location":"doc-cSharp/#filewriterfilereader","text":"Mit Hilfe des FileWriter und des FileReader ist es m\u00f6glich, Textdateien zu erstellen und diese bei Start des Programms einzulesen.","title":"FileWriter/FileReader"},{"location":"doc-cSharp/#file-writer","text":"Mit dem File Writer ist es m\u00f6glich, einen Dateipfad f\u00fcr eine Textdatei anzugeben und dann den Inhalt der Datei zu bestimmen. Hier folgendes Code-Beispiel: C# string DateiPfad = \"C:\\tmp\\Test.txt\" ; string Inhalt = \"Test\" ; File . WriteAllText ( DateiPfad , Inhalt ); In diesem Beispiel wird als Pfad \"C:\\tmp\\Test.txt\" angegeben. In die Textdatei wird dann ein String mit der Zeichenfolge \"Test\" hineingeschrieben.","title":"File Writer"},{"location":"doc-cSharp/#file-reader","text":"Mit Hilfe des File Reader ist es im Anschluss m\u00f6glich, die gespeicherte Textdatei wieder im Programm einzulesen und zum Beispiel einer Variable zuzuweisen. C# string DateiPfad = \"C:\\tmp\\Test.txt\" ; string Inhalt = \"\" ; Inhalt = File . ReadAllText ( DateiPfad );","title":"File Reader"}]}